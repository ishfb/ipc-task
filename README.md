# Описание выполненного задания

## Процессы 

Сделал два процесса:
- writer — принимает ввод от пользователя и пишет в общую память
- reader — читает содержимое общей памяти и вывод его в stdout, реагирует на команду 'H'

Оба они имеют два параметра командной строки:
- `<shared memory size in bytes>` — размер общей области памяти
- `-v` — вывод отладочной информации

## Создание общей области памяти

Общая область памяти создаётся в классе `SharedResource` с помощью вызова функций `shm_open` и `ftruncate`. Судя по документации, `ftruncate` нужно вызывать только после первичного создания разделяемой области памяти, но у меня без его вызова в каждом процессе не заработало (компилировал и запускал в WSL с Ubuntu 22.04).

Удаление разделяемой области памяти последним процессом реализовано в классе `UnlinkGuard`. Он получает ссылку на счётчик ссылок, который хранится в разделяемой области памяти. При запуске процесса этот счётчик увеличивается на 1, при завершении — уменьшается на 1. Если он стал равен нулю, вызывается функция `shm_unlink`.

Этот механизм ломается, если завершить процесс, нажав в консоли Ctrl+C. Поэтому для процессов заблокированы все сигналы. Это делается в классе `Environment::ArgsParser` (название не очень совпадает с назначанием, но я уже не стал полировать).

## Размещение строк в общей области памяти

В задании сказано, что строки в памяти надо размещать "оптимальным с точки зрения использования доступной памяти образом". Мне показалось, что нет ничего оптимальнее, чем выкладывать строки рядом друг с другом. К тому же в данном случае не надо выполнять дефрагментацию, что заметно упрощает выполнение задания. Поэтому я использую кольцевой буфер при выделении памяти для очередной строки. Он же прекрасно помогает удалять старые строки для размещения новой, если память кончилась.

Код содержится в классах `RingBufferAllocator` и `StringList`.

Чтобы отличать строки друг от друга, я записываю в буфер после каждой из них '\0'. Это даёт большие накладные расходы на хранение строк, если они все короткие. Но я исходил, что на вход приходят строки переменной длины, и использование дополнительного 1 байта на каждую из не сильно ударит по памяти.

## Коммуникация между процессами

Для сообщения читающему процессу о том, что появилась новая строка, я использую семафор (см. класс `IpcChannel`). Сначала я сделал просто счётчик в разделяемой памяти, на котором читающий процесс делал активное ожидание. Но это привело к жужжанию вентилятора моего ноутбука, и я понял, что надо всё же использовать что-то, что будет отправлять процесс в sleep. 

Я почитал про `pipe`, и мне показалось это сложным. Чтение и запись из/в них блокируются, пока к трубе не подключатся оба участника процесса. А работа с неблокирующими версиями мне показалась нетривиальной. 

Поэтому я взял семафор. Процесс `writer` на каждую новую строчку делает `sem_post`, а `reader` в отдельном потоке периодически вызывает `sem_timedwait`.

У этого подхода есть особенность поведения. Если сначала запустить `writer` и добавить в нём, например, 4 строки, а потом запустить `reader`, то он сразу после запуска 4 раза выведет в консоль последнюю добавленную строку.

## Вывод состояния общей памяти в `reader` 

В задании сказано "выводящий процесс при нажатии клавиши 'H' выводит всю имеющуюся историю строк из общей памяти". Я сделал это так, что `reader` читает пользовательский ввод из `stdin` и если ему пришла строка "H", он выводит строки из общей памяти. Надеюсь, такая реализация реакции на "нажатие клавиши 'H'" подойдёт. 

## Разное

Так как для процессов заблокирована реакция на сигналы, то завершить их можно введя строку "Q" с клавиатуры

## Дополнительные задания

### Дефрагментация

Как я сказал выше, я использую кольцевой буфер, укладывая строки рядом друг с другом. Поэтому память не фрагментируется. 

### Индекс для быстрого доступа к строкам в разделяемой памяти

Это часть задачи сформулирована очень мутно, поэтому непонятно было, что мы на самом деле хотим. После получения ответов на мои вопросы я понял её таким образом: «Мы хотим выводить в консоль все строки из общей памяти, которые начинаются на заданный префикс. При этом хотим получить минимальную **асимптотику поиска этих строк**».

Для индекса я использовал trie — дерево с выделенным корнем, на рёбрах которого записаны буквы, а в вершинах есть флаг, который говорит, является ли путь от корня до этой вершины словом из нашего набора. Считаю его оптимальным с точки зрения **асимптотики поиска**:
- нам нужно O(|prefix|) времени, чтобы найти вершину, в поддереве которой содержатся все строки из нашего набора с заданным префиксом. Быстрее O(|prefix|) поиск нельзя сделать, потому что нам как минимум надо считать весь префикс в память
- сбор всех строк из поддерева я делаю поиском глубину за O(суммарной длины найденных строк). Это тоже нельзя сделать асимптотически быстрее, потому что нам все равно надо вывести их все в `stdout`, что займёт то же время. 

Пункт "обрабатывать события изменения позиций строк для актуализации индекса" я никак не делал, потому что он, вероятно, относится к реакции на дефрагментацию, а у меня её нет. К тому же индекс у меня никак не смотрит в разделяюмую память, а по сути хранит копию строк оттуда. Выглядит странно, но для задачи "вывести все строки, начинающиеся с данного префикса, с минимально возможной асимптотикой" такое решение подходит. 